<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Space Cat Racing</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #000611;
  display: flex; align-items: center; justify-content: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  color: white; overflow: hidden;
}
canvas { display: block; }
#overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,15,0.92);
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 18px; z-index: 10;
}
h1 { font-size: 2.8em; color: #aaccff; letter-spacing: 4px; text-align: center; }
.subtitle { color: #6688cc; font-size: 1em; }
.cat-grid { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
.cat-card {
  border: 2px solid #334; background: #080818;
  padding: 12px 16px; border-radius: 10px; cursor: pointer;
  text-align: center; min-width: 110px; transition: all 0.15s;
}
.cat-card:hover { border-color: #66aaff; background: #0d1a33; transform: translateY(-2px); }
.cat-card.selected { border-color: #88ccff; background: #0a1525; box-shadow: 0 0 12px #2244aa; }
.cat-name { font-size: 1em; font-weight: bold; margin: 5px 0 3px; }
.cat-trait { font-size: 0.7em; color: #556; margin-bottom: 6px; }
.stat-bars { text-align: left; }
.stat-row { display: flex; align-items: center; gap: 5px; margin: 2px 0; }
.stat-label { font-size: 9px; width: 24px; }
.stat-bar { flex: 1; height: 3px; background: #223; border-radius: 2px; overflow: hidden; }
.stat-fill { height: 100%; border-radius: 2px; }
.start-btn {
  background: #0a1a4a; border: 2px solid #4488ff;
  color: #aaccff; padding: 12px 44px; font-size: 1.2em;
  border-radius: 8px; cursor: pointer; font-family: inherit;
  letter-spacing: 2px; transition: all 0.15s;
}
.start-btn:hover { background: #0f2260; box-shadow: 0 0 18px #2255cc; }
.hint { color: #445; font-size: 0.8em; }
.option-row { display:flex; gap:8px; align-items:center; }
.opt-label { color:#445; font-size:0.82em; min-width:42px; text-align:right; }
.opt-btn {
  border:1px solid #334; background:#080818; color:#556;
  padding:5px 16px; border-radius:6px; cursor:pointer;
  font-family:inherit; font-size:0.82em; transition:all 0.12s;
}
.opt-btn:hover { border-color:#558; color:#88aacc; }
.opt-btn.active { border-color:#66aaff; color:#aaccff; background:#0a1525; }
#finishSection { display: none; flex-direction: column; align-items: center; gap: 14px; }
.positions { display: flex; flex-direction: column; gap: 7px; }
.pos-row {
  display: flex; gap: 14px; align-items: center;
  padding: 6px 14px; border-radius: 6px; min-width: 280px;
}
.pos-row.you { background: #0a1a3a; border: 1px solid #446; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="overlay">
  <div id="menuSection">
    <h1>SPACE CAT RACING</h1>
    <p class="subtitle">Race your cat across the cosmos!</p>
    <div class="cat-grid" id="catGrid"></div>
    <div class="option-row">
      <span class="opt-label">Mode:</span>
      <button class="opt-btn active" id="modeRace">Race</button>
      <button class="opt-btn" id="modePractice">Practice</button>
    </div>
    <div class="option-row" id="diffRow">
      <span class="opt-label">AI:</span>
      <button class="opt-btn" id="diffEasy">Easy</button>
      <button class="opt-btn active" id="diffMedium">Medium</button>
      <button class="opt-btn" id="diffHard">Hard</button>
    </div>
    <button class="start-btn" id="startBtn">LAUNCH RACE</button>
    <p class="hint">Arrow Keys or WASD Â· S/â†“ to reverse</p>
  </div>
  <div id="finishSection">
    <h1>RACE COMPLETE!</h1>
    <div class="positions" id="finalPositions"></div>
    <button class="start-btn" id="replayBtn">RACE AGAIN</button>
  </div>
</div>

<script>
'use strict';

// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
canvas.width  = 900;
canvas.height = 650;

// â”€â”€ Cat definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CAT_TYPES = [
  { id:'tabby',     name:'Tabby',     trait:'All-rounder',  color:'#e8943a', stripe:'#b86018',
    maxSpeed:2.6, accel:0.11,  handling:0.058, grip:0.88, drag:0.015,
    stats:{ spd:3, acc:3, hdl:3, grp:4 } },
  { id:'persian',   name:'Persian',   trait:'Speed demon',  color:'#e8e0d0', stripe:'#aaa090',
    maxSpeed:3.1, accel:0.082, handling:0.044, grip:0.70, drag:0.011,
    stats:{ spd:5, acc:2, hdl:2, grp:2 } },
  { id:'siamese',   name:'Siamese',   trait:'Nimble',       color:'#d4b896', stripe:'#3a2018',
    maxSpeed:2.4, accel:0.14,  handling:0.074, grip:0.93, drag:0.018,
    stats:{ spd:2, acc:5, hdl:5, grp:5 } },
  { id:'mainecoon', name:'Maine Coon',trait:'Powerhouse',   color:'#8a7458', stripe:'#4a3020',
    maxSpeed:3.0, accel:0.068, handling:0.040, grip:0.76, drag:0.009,
    stats:{ spd:4, acc:1, hdl:1, grp:3 } },
  { id:'calico',    name:'Calico',    trait:'Lucky boost',  color:'#e8c870', stripe:'#c87030',
    maxSpeed:2.7, accel:0.115, handling:0.062, grip:0.85, drag:0.013,
    stats:{ spd:3, acc:3, hdl:3, grp:4 } },
  { id:'turkishvan', name:'Turkish Van', trait:'Chaos Agent', color:'#f0ece4', stripe:'#c04428',
    chaos:true,
    maxSpeed:3.2, accel:0.11, handling:0.058, grip:0.82, drag:0.013,
    stats:{ spd:5, acc:'?', hdl:'?', grp:'?' } },
];

// â”€â”€ Track definition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TRACK_W   = 88;   // track width in pixels
const TOTAL_LAPS = 3;
const CAR_R     = 10;   // car collision radius

// Control points for Catmull-Rom spline (closed loop)
const CP = [
  {x:720, y:330}, // 0 â€“ start/finish
  {x:790, y:230},
  {x:760, y:125},
  {x:640, y: 80},
  {x:500, y: 75},
  {x:360, y: 80},
  {x:240, y:118},
  {x:148, y:200},
  {x:128, y:315},
  {x:175, y:405},
  {x:290, y:445},
  {x:395, y:420},
  {x:430, y:492},
  {x:385, y:558},
  {x:468, y:592},
  {x:575, y:572},
  {x:650, y:500},
  {x:700, y:415},
];

// â”€â”€ Spline sampling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function crSample(p0, p1, p2, p3, t) {
  const t2 = t*t, t3 = t2*t;
  return {
    x: 0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(-p0.x+3*p1.x-3*p2.x+p3.x)*t3),
    y: 0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(-p0.y+3*p1.y-3*p2.y+p3.y)*t3),
  };
}

function buildSpline(cps, sps = 20) {
  const pts = [], n = cps.length;
  for (let i = 0; i < n; i++) {
    const p0 = cps[(i-1+n)%n], p1 = cps[i];
    const p2 = cps[(i+1)%n],   p3 = cps[(i+2)%n];
    for (let j = 0; j < sps; j++) pts.push(crSample(p0,p1,p2,p3, j/sps));
  }
  return pts;
}

const TRACK = buildSpline(CP, 20); // 360 points
const TN    = TRACK.length;

// Cumulative arc lengths
const ARC = [0];
for (let i = 1; i < TN; i++) {
  const dx = TRACK[i].x - TRACK[i-1].x, dy = TRACK[i].y - TRACK[i-1].y;
  ARC.push(ARC[i-1] + Math.hypot(dx, dy));
}
const LAP_LEN = ARC[TN-1] + Math.hypot(TRACK[0].x-TRACK[TN-1].x, TRACK[0].y-TRACK[TN-1].y);

// â”€â”€ Cached track canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildTrackCanvas() {
  const tc = document.createElement('canvas');
  tc.width = canvas.width; tc.height = canvas.height;
  const c = tc.getContext('2d');

  const drawPath = (lw, style) => {
    c.lineWidth = lw; c.strokeStyle = style;
    c.lineJoin = 'round'; c.lineCap = 'round';
    c.beginPath();
    c.moveTo(TRACK[0].x, TRACK[0].y);
    for (let i = 1; i < TN; i++) c.lineTo(TRACK[i].x, TRACK[i].y);
    c.closePath(); c.stroke();
  };

  drawPath(TRACK_W + 8, '#252545');   // border
  drawPath(TRACK_W,     '#16162a');   // surface

  // Dashed centre line
  c.setLineDash([14, 18]);
  drawPath(1.5, 'rgba(255,255,255,0.11)');
  c.setLineDash([]);

  // Start/finish line
  const sf = TRACK[0], sf1 = TRACK[1];
  const sfAngle = Math.atan2(sf1.y-sf.y, sf1.x-sf.x) + Math.PI/2;
  const hw = TRACK_W/2;
  c.lineWidth = 3; c.strokeStyle = '#ffffff';
  c.beginPath();
  c.moveTo(sf.x + Math.cos(sfAngle)*hw, sf.y + Math.sin(sfAngle)*hw);
  c.lineTo(sf.x - Math.cos(sfAngle)*hw, sf.y - Math.sin(sfAngle)*hw);
  c.stroke();

  // Checkerboard at start/finish
  const tang = Math.atan2(sf1.y-sf.y, sf1.x-sf.x);
  c.save(); c.translate(sf.x, sf.y); c.rotate(tang);
  const squares = 6, sq = TRACK_W / squares;
  for (let row = 0; row < 2; row++) {
    for (let col = 0; col < squares; col++) {
      if ((row+col)%2 === 0) {
        c.fillStyle = '#fff';
        c.fillRect(row*sq - sq, (col - squares/2)*sq, sq, sq);
      }
    }
  }
  c.restore();

  return tc;
}
const trackCanvas = buildTrackCanvas();

// â”€â”€ Stars & background objects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STARS = Array.from({length:220}, () => ({
  x: Math.random()*canvas.width, y: Math.random()*canvas.height,
  r: Math.random()*1.4 + 0.3,
  bright: Math.random(),
  ts: Math.random()*0.025 + 0.006,
  to: Math.random()*Math.PI*2,
}));

const NEBULAE = [
  {x:90,  y:75,  rx:100, ry:65, rot:0.4,  color:'rgba(80,40,160,0.13)'},
  {x:810, y:560, rx:80,  ry:55, rot:-0.5, color:'rgba(40,80,180,0.10)'},
  {x:460, y:320, rx:60,  ry:40, rot:1.2,  color:'rgba(20,100,60,0.08)'},
];

const PLANETS = [
  {x:830, y:80,  r:38, col:'#2e1860', ring:true,  ringCol:'rgba(180,140,80,0.45)'},
  {x:75,  y:578, r:22, col:'#164030', ring:false},
];

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'menu'; // menu | countdown | racing | waiting | finished
let cars = [], playerCar = null;
let countdown = 0, cdTimer = 0;
let raceTime = 0;
let finishOrder = [];
let selectedCat = 0;
let practiceMode = false;
let difficulty = 'medium';

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const KEYS = {};
addEventListener('keydown', e => { KEYS[e.code] = true;  e.preventDefault(); });
addEventListener('keyup',   e => { KEYS[e.code] = false; });

// â”€â”€ Car class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Car {
  constructor(cat, isPlayer, gridSlot) {
    this.cat = cat; this.isPlayer = isPlayer;

    // Grid positions: 5 slots arranged as starting grid just past S/F line
    const slots = [
      {along:  8, perp:  0},  // pole
      {along: -20, perp:-24},
      {along: -20, perp: 24},
      {along: -45, perp:-24},
      {along: -45, perp: 24},
      {along: -70, perp:  0},
    ];
    const slot = slots[gridSlot];

    const sf  = TRACK[0], sf1 = TRACK[1];
    const tang = Math.atan2(sf1.y-sf.y, sf1.x-sf.x);
    const perp = tang + Math.PI/2;

    this.x = sf.x + Math.cos(tang)*slot.along + Math.cos(perp)*slot.perp;
    this.y = sf.y + Math.sin(tang)*slot.along + Math.sin(perp)*slot.perp;
    this.angle = tang;

    this.vx = 0; this.vy = 0;
    this.tIdx = 0; // nearest track point index

    // Racing state
    this.lap = 1;
    this.passedHalf = false;
    this.lapDist = 0;          // distance traveled this lap (for ordering)
    this.totalDist = 0;        // for race position
    this.finished = false;
    this.finishTime = Infinity;
    this.prevTIdx = 0;

    // AI
    this.aiTarget = 5;
    this.aiSkill  = isPlayer ? 0 : (0.72 + Math.random()*0.28);
    this.aiSpeed  = isPlayer ? 1 : (0.88 + Math.random()*0.22);

    // Calico boost
    this.boost = 0;

    // Particles
    this.parts = [];

    // Steering smoothing (prevents instant snap)
    this.steerSmooth = 0;

    // Tail wag
    this.tailT = Math.random()*Math.PI*2;
    this.tailSpd = 0.08 + Math.random()*0.06;

    // Turkish Van â€“ random black patches on body (fixed per instance)
    this.vanPatches = cat.id === 'turkishvan' ? [
      { x: -5+Math.random()*4, y: (Math.random()>0.5?1:-1)*(2+Math.random()*3), rx: 2+Math.random()*2, ry: 1.2+Math.random()*1.5, rot: Math.random()*Math.PI },
      { x:  1+Math.random()*3, y: (Math.random()>0.5?1:-1)*(1+Math.random()*2), rx: 1+Math.random()*1.5, ry: 0.8+Math.random()*1,   rot: Math.random()*Math.PI },
    ] : [];
  }

  getSpeed() { return Math.hypot(this.vx, this.vy); }

  update(racing) {
    if (this.finished) return;
    this.tailT += this.tailSpd;

    // â”€â”€ Input / AI â”€â”€
    let steer = 0, accel = 0, brake = false;

    if (this.isPlayer) {
      if (KEYS['ArrowLeft']  || KEYS['KeyA']) steer = -1;
      if (KEYS['ArrowRight'] || KEYS['KeyD']) steer =  1;
      if (KEYS['ArrowUp']    || KEYS['KeyW']) accel =  1;
      if (KEYS['ArrowDown']  || KEYS['KeyS']) brake = true;
      if (this.cat.id === 'calico' && this.boost <= 0 && Math.random() < 0.002)
        this.boost = 70;
    } else {
      // Steer toward AI target waypoint
      const tgt = TRACK[this.aiTarget];
      const dx = tgt.x - this.x, dy = tgt.y - this.y;
      if (Math.hypot(dx,dy) < 40) this.aiTarget = (this.aiTarget+1)%TN;

      const want = Math.atan2(dy, dx);
      let diff = want - this.angle;
      while (diff >  Math.PI) diff -= Math.PI*2;
      while (diff < -Math.PI) diff += Math.PI*2;
      steer = Math.max(-1, Math.min(1, diff*2));

      // Slow for sharp corners ahead â€” look further so AI brakes in time
      const la = TRACK[(this.aiTarget+15)%TN];
      const la2= TRACK[(this.aiTarget+30)%TN];
      const v1x=la.x-tgt.x, v1y=la.y-tgt.y;
      const v2x=la2.x-la.x, v2y=la2.y-la.y;
      const dot=(v1x*v2x+v1y*v2y)/(Math.hypot(v1x,v1y)*Math.hypot(v2x,v2y)+0.001);
      const sharp = (1-dot)/2;
      const wantSpd = this.cat.maxSpeed * this.aiSpeed * (1-sharp*0.78);
      if (this.getSpeed() < wantSpd*this.aiSkill) accel = 1; else brake = true;

      if (this.cat.id==='calico' && this.boost<=0 && Math.random()<0.004) this.boost=70;
    }

    if (!racing) { accel=0; steer=0; brake=false; fwd *= 0.82; lat *= 0.82; }

    // â”€â”€ Steer smoothing (gradual, not instant snap) â”€â”€
    const steerRate = this.isPlayer ? 0.18 : 0.14;
    this.steerSmooth += (steer - this.steerSmooth) * steerRate;

    // â”€â”€ Physics â”€â”€
    const cosA = Math.cos(this.angle), sinA = Math.sin(this.angle);
    let fwd  =  this.vx*cosA + this.vy*sinA;
    let lat  = -this.vx*sinA + this.vy*cosA;

    lat *= (1 - this.cat.grip); // reduce lateral slip

    const bst = this.boost > 0 ? 1.4 : 1.0;
    if (accel) fwd += this.cat.accel * bst;
    if (brake) {
      if (fwd > 0.15) {
        fwd *= 0.88;                                   // braking while moving forward
      } else if (this.isPlayer) {
        fwd -= this.cat.accel * 0.55;                 // reverse for player
      } else {
        fwd *= 0.90;                                   // AI just coasts to stop
      }
    }
    fwd *= (1 - this.cat.drag);

    const effMax = this.cat.maxSpeed * bst;
    fwd = Math.max(-effMax*0.4, Math.min(effMax, fwd));

    // 0.3 minimum so the cat can turn in place when stopped/reversing
    const sfac = 0.3 + 0.7*Math.min(1, Math.abs(fwd)/(this.cat.maxSpeed*0.4));
    this.angle += this.steerSmooth * this.cat.handling * 0.72 * sfac * (fwd>=0?1:-1);

    const cosA2 = Math.cos(this.angle), sinA2 = Math.sin(this.angle);
    this.vx = cosA2*fwd - sinA2*lat;
    this.vy = sinA2*fwd + cosA2*lat;

    if (this.boost > 0) this.boost--;

    this.x += this.vx; this.y += this.vy;

    // â”€â”€ Wall collision â”€â”€
    let minD2 = Infinity, near = this.tIdx;
    const R = 50;
    for (let d = -R; d <= R; d++) {
      const i = ((this.tIdx+d)%TN+TN)%TN;
      const dx=this.x-TRACK[i].x, dy=this.y-TRACK[i].y;
      const d2=dx*dx+dy*dy;
      if (d2<minD2) { minD2=d2; near=i; }
    }
    this.tIdx = near;
    const dist = Math.sqrt(minD2);
    const lim  = TRACK_W/2 - CAR_R;
    if (dist > lim) {
      const tx=TRACK[near].x, ty=TRACK[near].y;
      const nx=(this.x-tx)/dist, ny=(this.y-ty)/dist;
      this.x = tx + nx*lim; this.y = ty + ny*lim;
      // Cancel only the wall-normal component; keep tangential so car can slide away
      const dot = this.vx*nx + this.vy*ny;
      if (dot > 0) { this.vx -= dot*nx; this.vy -= dot*ny; }
      this.vx *= 0.78; this.vy *= 0.78;
    }

    // â”€â”€ Lap counting â”€â”€
    const idx = this.tIdx;
    if (idx > TN*0.45) this.passedHalf = true;
    if (idx < TN*0.08 && this.passedHalf) {
      this.passedHalf = false;
      if (this.lap >= TOTAL_LAPS) {
        this.finished = true;
        this.finishTime = raceTime;
        finishOrder.push(this);
      } else {
        this.lap++;
      }
    }
    this.totalDist = (this.lap-1)*LAP_LEN + ARC[idx];

    // â”€â”€ Exhaust particles â”€â”€
    if (accel && this.getSpeed() > 0.6) {
      const ex = this.x - cosA2*13, ey = this.y - sinA2*13;
      this.parts.push({
        x:ex, y:ey,
        vx:(Math.random()-0.5)*0.9 - cosA2*0.6,
        vy:(Math.random()-0.5)*0.9 - sinA2*0.6,
        life:1, max:20+Math.random()*15,
        sz:3+Math.random()*2,
        col: this.boost>0 ? [255,200,50] : [80,140,255],
      });
    }
    this.parts = this.parts.filter(p => {
      p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95;
      p.life -= 1/p.max;
      return p.life>0;
    });
  }

  draw() {
    // Particles
    for (const p of this.parts) {
      ctx.globalAlpha = p.life*0.55;
      ctx.fillStyle = `rgb(${p.col[0]},${p.col[1]},${p.col[2]})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.sz*p.life, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    const bodyCol = this.boost > 0 ? '#ffee44' : this.cat.color;

    // Shadow
    ctx.shadowBlur = 6; ctx.shadowColor = 'rgba(0,0,0,0.6)';

    // Body
    ctx.fillStyle = bodyCol;
    ctx.beginPath(); ctx.ellipse(0,0,12,8,0,0,Math.PI*2); ctx.fill();

    // Stripe / Van body patches
    if (this.cat.id === 'turkishvan') {
      ctx.fillStyle = '#111';
      for (const p of this.vanPatches) {
        ctx.beginPath(); ctx.ellipse(p.x,p.y,p.rx,p.ry,p.rot,0,Math.PI*2); ctx.fill();
      }
    } else {
      ctx.fillStyle = this.cat.stripe;
      ctx.beginPath(); ctx.ellipse(-1,0,4,5.5,0,0,Math.PI*2); ctx.fill();
    }

    // Head
    ctx.fillStyle = bodyCol;
    ctx.beginPath(); ctx.arc(11,0,7,0,Math.PI*2); ctx.fill();

    // Turkish Van head patch (top of head, between ears)
    if (this.cat.id === 'turkishvan') {
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.ellipse(10,-2.5,4.5,3,0.25,0,Math.PI*2); ctx.fill();
    }

    // Ears
    ctx.shadowBlur = 0;
    ctx.fillStyle = bodyCol;
    for (const s of [-1,1]) {
      ctx.beginPath();
      ctx.moveTo(9,s*-6); ctx.lineTo(14,s*-11); ctx.lineTo(16,s*-4);
      ctx.fill();
    }
    ctx.fillStyle = '#ff99aa';
    for (const s of [-1,1]) {
      ctx.beginPath();
      ctx.moveTo(10,s*-6); ctx.lineTo(13,s*-9); ctx.lineTo(15,s*-5);
      ctx.fill();
    }

    // Eyes
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.ellipse(12,-2.5,1.8,1.3,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(12, 2.5,1.8,1.3,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#88ddff';
    ctx.beginPath(); ctx.arc(11.2,-2.9,0.6,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(11.2, 2.1,0.6,0,Math.PI*2); ctx.fill();

    // Nose
    ctx.fillStyle = '#ff6688';
    ctx.beginPath(); ctx.arc(16,0,1.4,0,Math.PI*2); ctx.fill();

    // Whiskers
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 0.7;
    for (const s of [-1,1]) {
      ctx.beginPath(); ctx.moveTo(15,s*1); ctx.lineTo(22,s*2.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(15,s*1); ctx.lineTo(22,0);     ctx.stroke();
    }

    // Tail
    const wag = Math.sin(this.tailT) * 8;
    ctx.strokeStyle = (this.cat.id === 'turkishvan' && this.boost <= 0) ? '#111' : bodyCol;
    ctx.lineWidth = 3.5; ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(-12, 0);
    ctx.quadraticCurveTo(-19, wag, -15, wag + 10*Math.sign(wag||1));
    ctx.stroke();

    // Boost glow
    if (this.boost > 0) {
      ctx.globalAlpha = 0.25 + 0.2*Math.sin(this.boost*0.4);
      ctx.strokeStyle = '#ffee44'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.ellipse(0,0,16,12,0,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Player arrow indicator
    if (this.isPlayer) {
      ctx.strokeStyle = '#88ccff'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.8;
      ctx.beginPath(); ctx.arc(0,-20,4,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(0,-11); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }
}

// â”€â”€ Background drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBg(t) {
  ctx.fillStyle = '#000811';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Nebulae
  for (const n of NEBULAE) {
    ctx.save(); ctx.translate(n.x,n.y); ctx.rotate(n.rot);
    const g = ctx.createRadialGradient(0,0,0,0,0,n.rx);
    g.addColorStop(0, n.color); g.addColorStop(1,'transparent');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.ellipse(0,0,n.rx,n.ry,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Stars
  for (const s of STARS) {
    const tw = 0.35 + 0.65*(0.5+0.5*Math.sin(t*s.ts+s.to));
    ctx.globalAlpha = tw;
    ctx.fillStyle = `hsl(${200+s.bright*60},40%,${65+s.bright*30}%)`;
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Planets
  for (const p of PLANETS) {
    ctx.save(); ctx.translate(p.x, p.y);

    // Glow
    const glow = ctx.createRadialGradient(0,0,p.r*0.6,0,0,p.r*2);
    glow.addColorStop(0, p.col+'50'); glow.addColorStop(1,'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(0,0,p.r*2,0,Math.PI*2); ctx.fill();

    // Body
    const gr = ctx.createRadialGradient(-p.r*0.3,-p.r*0.3,0,0,0,p.r);
    gr.addColorStop(0, lighten(p.col,45)); gr.addColorStop(1, darken(p.col,25));
    ctx.fillStyle = gr;
    ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();

    // Ring
    if (p.ring) {
      ctx.save(); ctx.rotate(-0.3); ctx.scale(1,0.32);
      ctx.beginPath();
      ctx.arc(0,0,p.r*2.3,0,Math.PI*2);
      ctx.arc(0,0,p.r*1.25,0,Math.PI*2,true);
      ctx.fillStyle = p.ringCol; ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }
}

function lighten(hex, a) {
  const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);
  return `rgb(${Math.min(255,r+a)},${Math.min(255,g+a)},${Math.min(255,b+a)})`;
}
function darken(hex, a) {
  const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);
  return `rgb(${Math.max(0,r-a)},${Math.max(0,g-a)},${Math.max(0,b-a)})`;
}

// â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function panel(x,y,w,h,r=8) {
  ctx.fillStyle='rgba(0,0,15,0.78)';
  ctx.beginPath(); ctx.roundRect(x,y,w,h,r); ctx.fill();
  ctx.strokeStyle='#334'; ctx.lineWidth=1; ctx.stroke();
}

function drawHUD() {
  if (!playerCar) return;

  // Info panel
  panel(10,10,200,88);
  ctx.fillStyle='#aaccff'; ctx.font='bold 14px Courier New';
  const lapTxt = playerCar.finished ? `FINISHED!` : `Lap ${playerCar.lap} / ${TOTAL_LAPS}`;
  ctx.fillText(lapTxt, 20, 33);

  const sortedCars = [...cars].sort((a,b)=>{
    if (a.finished && b.finished) return a.finishTime - b.finishTime;
    if (a.finished) return -1;
    if (b.finished) return 1;
    return b.totalDist - a.totalDist;
  });
  const pos = sortedCars.findIndex(c=>c===playerCar)+1;
  const suf = ['st','nd','rd','th','th','th'];
  const posTxt = practiceMode ? 'Practice' : `Position: ${pos}${suf[Math.min(pos-1,5)]}`;
  ctx.fillText(posTxt, 20, 53);

  const sec = Math.floor(raceTime/60), min=Math.floor(sec/60);
  const ms  = Math.floor((raceTime%60)*1000/60);
  ctx.fillStyle='#8899bb'; ctx.font='12px Courier New';
  ctx.fillText(`${min}:${String(sec%60).padStart(2,'0')}.${String(ms).padStart(3,'0')}`, 20, 72);

  // Speed bar
  panel(10,104,200,26,6);
  const spd = playerCar.getSpeed(), spc = spd/playerCar.cat.maxSpeed;
  ctx.fillStyle = spc>0.85?'#ff5533':spc>0.5?'#ffdd44':'#44ff88';
  ctx.beginPath(); ctx.roundRect(12,106,196*spc,22,4); ctx.fill();
  ctx.fillStyle='#fff'; ctx.font='bold 11px Courier New'; ctx.textAlign='center';
  ctx.fillText(`${Math.round(spd*85)} km/h`, 110, 121);
  ctx.textAlign='left';

  // Mini-map
  drawMiniMap();

  // Race positions panel (hidden in practice mode)
  if (!practiceMode) drawPositions(sortedCars);

  // Countdown overlay
  if (state === 'countdown') {
    ctx.fillStyle='rgba(0,0,0,0.45)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const frame = Math.floor(cdTimer);
    const numVal = 3 - Math.floor(frame/60);
    const alpha  = Math.min(1, (frame%60)/18);
    ctx.globalAlpha = alpha;
    ctx.textAlign='center';
    ctx.font='bold 130px Courier New';
    const isGo = frame >= 180;
    ctx.fillStyle = isGo ? '#44ff88' : '#ffdd44';
    ctx.shadowBlur=35; ctx.shadowColor=ctx.fillStyle;
    ctx.fillText(isGo ? 'GO!' : String(numVal), canvas.width/2, canvas.height/2+45);
    ctx.shadowBlur=0; ctx.globalAlpha=1; ctx.textAlign='left';
  }

  // Calico boost flash
  if (playerCar.cat.id==='calico' && playerCar.boost>0) {
    ctx.fillStyle='#ffee44'; ctx.font='bold 18px Courier New'; ctx.textAlign='center';
    ctx.fillText('âš¡ LUCKY BOOST! âš¡', canvas.width/2, canvas.height-28);
    ctx.textAlign='left';
  }
}

function drawMiniMap() {
  const MX=10, MY=canvas.height-138, MW=148, MH=128;
  panel(MX,MY,MW,MH);
  ctx.save();
  ctx.beginPath(); ctx.roundRect(MX,MY,MW,MH,8); ctx.clip();

  const minX=Math.min(...TRACK.map(p=>p.x))-15;
  const minY=Math.min(...TRACK.map(p=>p.y))-15;
  const maxX=Math.max(...TRACK.map(p=>p.x))+15;
  const maxY=Math.max(...TRACK.map(p=>p.y))+15;
  const sc = Math.min(MW/(maxX-minX), MH/(maxY-minY))*0.92;
  const ox = MX+(MW-(maxX-minX)*sc)/2, oy = MY+(MH-(maxY-minY)*sc)/2;
  const mm = p => ({x:ox+(p.x-minX)*sc, y:oy+(p.y-minY)*sc});

  ctx.lineWidth=TRACK_W*sc; ctx.strokeStyle='#252545';
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.beginPath();
  const fp=mm(TRACK[0]); ctx.moveTo(fp.x,fp.y);
  for (let i=1;i<TN;i++) { const p=mm(TRACK[i]); ctx.lineTo(p.x,p.y); }
  ctx.closePath(); ctx.stroke();

  for (const car of cars) {
    const p=mm(car);
    ctx.fillStyle = car.isPlayer ? '#88ccff' : car.cat.color;
    ctx.beginPath(); ctx.arc(p.x,p.y, car.isPlayer?4:3, 0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawPositions(sorted) {
  const x=164, y=canvas.height-138, w=156, rowH=21;
  panel(x,y,w, 8+sorted.length*rowH);
  ctx.font='11px Courier New';
  const medals=['1st','2nd','3rd','4th','5th'];
  sorted.forEach((car,i) => {
    const ry = y+6+i*rowH;
    if (car.isPlayer) {
      ctx.fillStyle='rgba(30,50,100,0.5)';
      ctx.fillRect(x+2, ry, w-4, rowH-1);
    }
    ctx.fillStyle = medals[i]==='1st'?'#ffdd44':medals[i]==='2nd'?'#cccccc':medals[i]==='3rd'?'#dd9944':'#667';
    ctx.fillText(medals[i], x+8, ry+15);
    ctx.fillStyle = car.cat.color;
    ctx.fillText(car.cat.name, x+40, ry+15);
    if (car.isPlayer) { ctx.fillStyle='#aaccff'; ctx.fillText('YOU', x+w-28, ry+15); }
  });
}

// â”€â”€ Race setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rollChaos(cat) {
  if (!cat.chaos) return cat;
  const acc = 0.08  + Math.random()*0.15;
  const hdl = 0.030 + Math.random()*0.065;
  const grp = 0.58  + Math.random()*0.38;
  const drg = 0.008 + Math.random()*0.016;
  return Object.assign({}, cat, {
    accel: acc, handling: hdl, grip: grp, drag: drg,
    stats: {
      spd: 5,
      acc: Math.round(acc / 0.04),
      hdl: Math.round(hdl / 0.02),
      grp: Math.round(grp / 0.22),
    },
  });
}

function startRace() {
  cars = []; finishOrder = []; raceTime = 0;

  const playerType = rollChaos(CAT_TYPES[selectedCat]);
  playerCar = new Car(playerType, true, 0);
  cars.push(playerCar);

  if (!practiceMode) {
    const dm = { easy:{skill:0.60,speed:0.66}, medium:{skill:1,speed:1}, hard:{skill:1.12,speed:1.08} }[difficulty];
    const aiTypes = CAT_TYPES.filter((_,i)=>i!==selectedCat).map(rollChaos);
    aiTypes.forEach((cat,i) => {
      const ai = new Car(cat, false, i+1);
      ai.aiSkill *= dm.skill;
      ai.aiSpeed *= dm.speed;
      cars.push(ai);
    });
  }

  cdTimer = 0; state = 'countdown';
  document.getElementById('overlay').style.display = 'none';
}

// â”€â”€ Finish screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showFinish() {
  const sorted = [...cars].sort((a,b) => {
    if (a.finished && b.finished) return a.finishTime - b.finishTime;
    if (a.finished) return -1;
    if (b.finished) return 1;
    return b.totalDist - a.totalDist;
  });

  const medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','4th','5th'];
  const posDiv = document.getElementById('finalPositions');
  posDiv.innerHTML = '';

  sorted.forEach((car,i) => {
    const div = document.createElement('div');
    div.className = 'pos-row' + (car.isPlayer?' you':'');
    let timeStr = 'â€“';
    if (car.finished) {
      const s=Math.floor(car.finishTime/60), m=Math.floor(s/60);
      const ms=Math.floor((car.finishTime%60)*1000/60);
      timeStr = `${m}:${String(s%60).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
    }
    div.innerHTML =
      `<span>${medals[i]}</span>` +
      `<span style="color:${car.cat.color};min-width:90px">${car.cat.name}</span>` +
      `<span style="color:#667">${timeStr}</span>` +
      (car.isPlayer ? `<span style="color:#aaccff"> â† you</span>` : '');
    posDiv.appendChild(div);
  });

  document.getElementById('menuSection').style.display = 'none';
  document.getElementById('finishSection').style.display = 'flex';
  document.getElementById('overlay').style.display = 'flex';
}

// â”€â”€ Cat selection UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildCatGrid() {
  const grid = document.getElementById('catGrid');
  grid.innerHTML = '';
  CAT_TYPES.forEach((cat, i) => {
    const card = document.createElement('div');
    card.className = 'cat-card' + (i===selectedCat?' selected':'');

    // Mini canvas preview
    const mc = document.createElement('canvas');
    mc.width=60; mc.height=50;
    const mctx = mc.getContext('2d');
    mctx.translate(22,28);
    const isVan = cat.id === 'turkishvan';
    mctx.fillStyle = cat.color;
    mctx.beginPath(); mctx.ellipse(0,0,10,7,0,0,Math.PI*2); mctx.fill();
    // Body marking
    if (isVan) {
      mctx.fillStyle = '#111';
      mctx.beginPath(); mctx.ellipse(-4,3,2,1.5,0.5,0,Math.PI*2); mctx.fill();
      mctx.beginPath(); mctx.ellipse(1,-3,1.5,1,0.3,0,Math.PI*2); mctx.fill();
    } else {
      mctx.fillStyle = cat.stripe;
      mctx.beginPath(); mctx.ellipse(-1,0,3.5,5,0,0,Math.PI*2); mctx.fill();
    }
    mctx.fillStyle = cat.color;
    mctx.beginPath(); mctx.arc(10,0,6,0,Math.PI*2); mctx.fill();
    // Head patch for Van
    if (isVan) {
      mctx.fillStyle = '#111';
      mctx.beginPath(); mctx.ellipse(9,-2,4,2.5,0.25,0,Math.PI*2); mctx.fill();
    }
    mctx.fillStyle = '#ff99aa';
    mctx.beginPath(); mctx.moveTo(8,-5); mctx.lineTo(12,-9); mctx.lineTo(14,-4); mctx.fill();
    mctx.beginPath(); mctx.moveTo(8,5);  mctx.lineTo(12,9);  mctx.lineTo(14,4);  mctx.fill();
    mctx.fillStyle='#111';
    mctx.beginPath(); mctx.ellipse(11,-2,1.5,1,0,0,Math.PI*2); mctx.fill();
    mctx.beginPath(); mctx.ellipse(11, 2,1.5,1,0,0,Math.PI*2); mctx.fill();
    // Tail â€“ black for Van
    mctx.strokeStyle = isVan ? '#111' : cat.color;
    mctx.lineWidth=3; mctx.lineCap='round';
    mctx.beginPath(); mctx.moveTo(-10,0); mctx.quadraticCurveTo(-16,-5,-12,-14); mctx.stroke();
    card.appendChild(mc);

    const nm = document.createElement('div'); nm.className='cat-name';
    nm.style.color=cat.color; nm.textContent=cat.name; card.appendChild(nm);

    const tr = document.createElement('div'); tr.className='cat-trait';
    tr.textContent=cat.trait; card.appendChild(tr);

    const sb = document.createElement('div'); sb.className='stat-bars';
    const statDefs = [{k:'spd',l:'SPD',c:'#ff6644'},{k:'acc',l:'ACC',c:'#ffdd44'},
                      {k:'hdl',l:'HDL',c:'#44ddff'},{k:'grp',l:'GRP',c:'#44ff88'}];
    statDefs.forEach(sd => {
      const row = document.createElement('div'); row.className='stat-row';
      const val = cat.stats[sd.k];
      const isUnknown = val === '?';
      row.innerHTML=`<span class="stat-label" style="color:${sd.c}">${sd.l}</span>`+
        (isUnknown
          ? `<div class="stat-bar" style="display:flex;align-items:center;justify-content:center"><span style="color:#ff44cc;font-size:10px;font-weight:bold">???</span></div>`
          : `<div class="stat-bar"><div class="stat-fill" style="width:${val*20}%;background:${sd.c}"></div></div>`);
      sb.appendChild(row);
    });
    card.appendChild(sb);

    card.addEventListener('click',()=>{ selectedCat=i; buildCatGrid(); });
    grid.appendChild(card);
  });
}

// â”€â”€ Main loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastT = 0;
let waitFinishScheduled = false;

function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min((ts-lastT)/16.67, 3);
  lastT = ts;
  const t  = ts*0.001;

  drawBg(t);

  if (state==='menu') {
    ctx.fillStyle='rgba(0,0,10,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    return;
  }

  // Countdown tick
  if (state==='countdown') {
    cdTimer += dt;
    if (cdTimer >= 240) state = 'racing';
  }

  const racing = state==='racing';

  // Update
  for (const car of cars) car.update(racing);

  if (racing) {
    raceTime += dt;

    // Check player finished
    if (playerCar && playerCar.finished && !waitFinishScheduled) {
      waitFinishScheduled = true;
      state = 'waiting';
      setTimeout(() => { state='finished'; showFinish(); }, 2500);
    }

    // Safety timeout ~8 minutes
    if (raceTime > 60*60*8) { state='finished'; showFinish(); }
  }

  // Track
  ctx.drawImage(trackCanvas, 0, 0);

  // Cars (sorted by y for depth)
  [...cars].sort((a,b)=>a.y-b.y).forEach(c=>c.draw());

  // HUD
  drawHUD();
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
buildCatGrid();

function setMode(isPractice) {
  practiceMode = isPractice;
  document.getElementById('modeRace').classList.toggle('active', !isPractice);
  document.getElementById('modePractice').classList.toggle('active', isPractice);
  document.getElementById('diffRow').style.display = isPractice ? 'none' : 'flex';
}
function setDiff(d) {
  difficulty = d;
  ['Easy','Medium','Hard'].forEach(n =>
    document.getElementById('diff'+n).classList.toggle('active', d===n.toLowerCase())
  );
}
document.getElementById('modeRace').addEventListener('click', () => setMode(false));
document.getElementById('modePractice').addEventListener('click', () => setMode(true));
document.getElementById('diffEasy').addEventListener('click', () => setDiff('easy'));
document.getElementById('diffMedium').addEventListener('click', () => setDiff('medium'));
document.getElementById('diffHard').addEventListener('click', () => setDiff('hard'));

document.getElementById('startBtn').addEventListener('click', () => {
  waitFinishScheduled = false;
  startRace();
});
document.getElementById('replayBtn').addEventListener('click', () => {
  waitFinishScheduled = false;
  document.getElementById('finishSection').style.display='none';
  document.getElementById('menuSection').style.display='flex';
  document.getElementById('menuSection').style.flexDirection='column';
  document.getElementById('menuSection').style.alignItems='center';
  document.getElementById('menuSection').style.gap='18px';
  state='menu';
});

requestAnimationFrame(loop);
</script>
</body>
</html>
